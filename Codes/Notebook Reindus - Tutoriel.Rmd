
---
title: "Notebook réindustrialisation : Tutoriel sur le chargement et la manipulation ds données"
author: "Alexandre BOURGEOIS"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
%\VignetteIndexEntry{Vignette Title}
%\VignetteEngine{knitr::rmarkdown}
\usepackage[utf8]{inputenc}
---

**Loading of packages and global parameters**

```{r setup, include=FALSE}
# Display of the code ?
#knitr::opts_chunk$set(echo = TRUE) 

# Loading packages
library(microbenchmark)
library(RcppArmadillo)
library(Rcpp)
library(dplyr)
library(ggfortify)
library(dplyr)
library(stringr)
library(tidyverse)
library(readxl)
library(readODS)
library(R6)
library(tidyr)
library(writexl)
library(WriteXLS)
library(xlsx)
library(ggplot2)
library(roxygen2)
library(devtools)
library(forecast)
library(fable)
library(Metrics)
library(xts)
library(data.table)

source("Reindus functions.R")


### Chemins d'accès
Path_FIG22ixi<-"X:/HAB-Empreinte-carbone/MRIO/02_Bases ICIO et MRIO/FIGARO 2022/ixi/"
Path_FIG22pxp<-"X:/HAB-Empreinte-carbone/MRIO/02_Bases ICIO et MRIO/FIGARO 2022/pxp/"
Path_FIG22emi<-"X:/HAB-Empreinte-carbone/MRIO/04_Bases_emissions_GES/FIGARO 22/CO2/"
Path_SIOTEurostat <-"X:/HAB-Empreinte-carbone/MRIO/02_Bases ICIO et MRIO/SIOT_Eurostat/"
PathS<-"Sorties/"
Path_WIODLR<-"X:/HAB-Empreinte-carbone/MRIO/02_Bases ICIO et MRIO/WIOD-LR 2022/"
Path_WIOD<-"X:/HAB-Empreinte-carbone/MRIO/02_Bases ICIO et MRIO/WIOD 2016 release/"
Path_TabPass<-"X:/HAB-Empreinte-carbone/MRIO/05_Tables de passage/"


### Chargement des tables de départ
BASE_ECOLE<-readRDS("Sorties/BASE_ECOLE.rds")
BASE_A17<-readRDS("Sorties/BASE_A17.rds")
BASE_LRWIOD<-readRDS("Sorties/BDn_LR_WIOD.rds")
BASE_WIOD<-readRDS("Sorties/BDn_WIOD.rds")
BASE_FIG<-readRDS("Sorties/BDn_FIG.rds")


### Chargement des tables de résultats

# Chargement des résultats sur le MADE-IN
BASEres_MADEINs_ECOLE<-readRDS("Sorties/RESULT_MADEINs_ECOLE.rds")
BASEres_MADEINs_A17<-readRDS("Sorties/RESULT_MADEINs_A17.rds")
BASEres_MADEINs_LRWIO<-readRDS("Sorties/RESULT_MADEINs_LRWIOD.rds")
BASEres_MADEINs_WIOD<-readRDS("Sorties/RESULT_MADEINs_WIOD.rds")
BASEres_MADEINs_FIGARO<-readRDS("Sorties/RESULT_MADEINs_FIGARO.rds")

# Chargement des résultats sur le contenu en VA des exports
BASEres_ContVAdesExports_ECOLE<-readRDS("Sorties/RESULT_ContVAdesExports_ECOLE.rds")
BASEres_ContVAdesExports_A17<-readRDS("Sorties/RESULT_ContVAdesExports_A17.rds")
BASEres_ContVAdesExports_LRWIOD<-readRDS("Sorties/RESULT_ContVAdesExports_LRWIOD.rds")
#BASEres_ContVAdesExports_WIOD<-readRDS("Sorties/RESULT_ContVAdesExports_WIOD.rds") # pas fait pour l'instant : A refaire car on a ajouté la VA et les Exports
#BASEres_ContVAdesExports_FIGARO<-readRDS("Sorties/RESULT_ContVAdesExports_FIGARO.rds") # pas fait pour l'instant : trop longue a constituer

# Chargement des résultats sur GAO
BASEres_GAO_ECOLE<-readRDS("Sorties/RESULT_GAO_ECOLE.rds")
BASEres_GAO_A17<-readRDS("Sorties/RESULT_GAO_A17.rds")
BASEres_GAO_LRWIOD<-readRDS("Sorties/RESULT_GAO_LRWIOD.rds")
#BASEres_GAO_WIOD<-readRDS("Sorties/RESULT_GAO_WIOD.rds") # pas fait pour l'instant : trop longue a constituer
#BASEres_GAO_FIGARO<-readRDS("Sorties/RESULT_GAO_FIGARO.rds") # pas fait pour l'instant : trop longue a constituer

# Chargement des résultats sur les linkage backward et forward
BASEres_LinkageBwdFwd_ECOLE<-readRDS("Sorties/RESULT_LinkageBwdFwd_ECOLE.rds")
BASEres_LinkageBwdFwd_A17<-readRDS("Sorties/RESULT_LinkageBwdFwd_A17.rds")
BASEres_LinkageBwdFwd_LRWIOD<-readRDS("Sorties/RESULT_LinkageBwdFwd_LRWIOD.rds")


### Fonctions utiles
cppFunction("arma::mat CFPcalculationRCPP(arma::mat ef, arma::mat L,arma::mat  FD){return ef*L*FD;}",
            depends="RcppArmadillo")
cppFunction("arma::mat inversion_rcpp3(arma::mat m1){arma::mat m2 = inv(m1); return(m2);}",
            depends="RcppArmadillo")
cppFunction("arma::mat Mult2_rcpp3(arma::mat matA, arma::mat matB){return matA*matB;}",
            depends="RcppArmadillo")
# Fonction de transformation en vecteur dataframe
vectDF<- function(vect){
  out<-as.data.frame(vect, drop=FALSE)
  return(out)
}
# Fonction pour convertir les infinity en NA et les NA en 0 ou 1 par exemple
GereInfNA <- function(df,impute=0){  
  if(ncol(df)==1){ # Si c'est un vecteur qui est gere comme une liste
  df<-lapply(df, function(x) {
    x[is.infinite(x)] <- impute 
    return(x)
    } )
  df<-lapply(df, function(x) {
    x[is.na(x)] <- impute 
    return(x)
  } )
  df<-vectDF(df)
}else{ # Si c'est une matrice avec plusieurs colonnes
  is.na(df)<-sapply(df, is.infinite)
  df[is.na(df)]<-impute
}
  return(df)
}
GetRownamesFromFirstCol <- function(df)
{
  df<-as.data.frame(df)
  rownames(df)<-as.character(df[,1])
  dfout<-df[,-1,drop=FALSE]
  return (dfout)
}
AddRownamesToFirstCol <- function(df)
{
  df<-as.data.frame(df)
  df2<-cbind(rownames(df),df)
  df2<-as.data.frame(df2)
  colnames(df2)[1]<-"joint"
  return (df2)
}

```

Manipulation des bases ECOLE et A17 (sur toutes la période, normalisées en termes de pays sur LRWIOD, avec distinction du MRIO)
```{r}
# Selection du l'année 2020 sur la base école (résultat DT - format data.table)
Test_Ecole_2020<-BASE_ECOLE[year==2020,]  # Commentaire : c'est donc le MRIO Figaro qui est présenté ici
Test_Ecole_2012<-BASE_ECOLE[year==2012,]  # Commentaire : ici on a 2 MRIO (WIOD et FIGARO) comme nosu sommes sur al période de recouvrement.
Test_Ecole_2000<-BASE_ECOLE[year==2000,]  # Commentaire : ici on a 2 MRIO (LRWIOD et WIOD) comme nosu sommes sur l'année de  recouvrement des 2 bases.

 Test_A17_2000 <-BASE_A17[year==2000,]
 
 # Mise en format 'tableau' avec dcast (comme un tableau croisé dynamique / a noter l'opération inverse qui est melt())
 Test_A17_2000dcast<-dcast(Test_A17_2000,Lig_Country + Lig_Indus + Col_Country + Col_Indus ~ MRIO + year ,value.var="value") # Commentaire : on observe 2 choses intéressantes : les codes de demande finale ne sont pas les mêmes entre les 2 MRIO (LR_WIOD et WIOD) et dans LR_WIOD il manque 2 codes branche (MN et OQ) car la table de passage n'était pas exacte compte tenu que le système de nomenclature est différent entre LR_WIOD (NAF Rev.1) et WIOD (NAF Rev.2). --> LR_WIOD ne comprends que 15 produits au lieu de 17. Faire particulièrement attention au passage de l'année 2000 : s'il y a des sauts importants dans les séries il peut être judicieux d'utiliser directement BASE_LRWIOD (23 branches) avant 2000 puis BASE_A17 (17 branches) après 

# Recupérer des listes de codes branche ou pays
Liste_Branches_BASE_A17_enLigne<-unique(BASE_A17[,Lig_Indus])
print(Liste_Branches_BASE_A17_enLigne) # On remarque qu'en ligne on a la production (GO=Gross Output) et la VA (valeur ajoutée)
Liste_Branches_BASE_A17_enColonne<-unique(BASE_A17[,Col_Indus])
print(Liste_Branches_BASE_A17_enColonne) # On remarque qu'en colonne les composantes de la demande finale correspondant 3 bases (sur différentes dates).
Liste_Branches_BASE_ECOLE_enLigne<-unique(BASE_ECOLE[,Lig_Indus])
print(Liste_Branches_BASE_ECOLE_enLigne) # On remarque qu'en ligne on a la production (GO=Gross Output) et la VA (valeur ajoutée)
Liste_Branches_BASE_ECOLE_enColonne<-unique(BASE_ECOLE[,Col_Indus])
print(Liste_Branches_BASE_ECOLE_enColonne) # On remarque qu'en colonne les composantes de la demande finale correspondant 3 bases (sur différentes dates).
Liste_Pays_BASE_ECOLE_enLigne<-unique(BASE_ECOLE[,Lig_Country])
print(Liste_Pays_BASE_ECOLE_enLigne) # De manière équivalente sur les pays... (attention TOTAL sert a distinguer ce qui en Branche n'est pas affectable a un pays)
Liste_Pays_BASE_A17_enLigne<-unique(BASE_A17[,Lig_Country])
print(Liste_Pays_BASE_A17_enLigne) # De manière équivalente sur les pays... (attention TOT sert a distinguer ce qui en Branche n'est pas affectable a un pays)

# Effectuer des sélections légèrement plus complexes
Test_Ecole_select<-BASE_ECOLE[year==2020 & Lig_Country==Col_Country,] # Sélection des parties domestiques pour l'année 2020 sur BASE_ECOLE
Test_Ecole_select<-BASE_ECOLE[year==2020 & Lig_Country==Col_Country & Lig_Country=="FRA",] # Pareil en sélectionnant uniquement la France   --> on remarque qu'on sélectionne a la fois les CI et la demande finale.
Test_Ecole_select<-BASE_ECOLE[year==2020 & Lig_Country=="FRA",] # Ici sélection de l'équilibre ressources emploi de la FRA : production et CI et DF (décomposées par pays et branche de destination)
Test_Ecole_select<-rbind(BASE_ECOLE[Col_Country=="PROD" & Lig_Country=="FRA",],BASE_ECOLE[Lig_Indus=="GO" & Col_Country=="FRA",],BASE_ECOLE[Lig_Indus=="xGO" & Col_Country=="FRA",]) # Attention petite subtilité pour la production qui est parfois en ligne et parfois en colonne. 

# Faire une requete de sommation avec ReqSum :
Test_Ecole_ReqSum<-ReqSum(BASE_ECOLE[year==2020,],c("Lig_Country","Col_Country"),OptMRIO=T) # On agrège les pays en une seule zoge géographique et on conserve la distinction par branches et notamment la demande finale.
Test_Ecole_ReqSum<-ReqSum(BASE_ECOLE[year==2020,],c("Lig_Indus","Col_Indus"),OptMRIO=T) # l'inverse de l ligne précédente.
Test_Ecole_ReqSum<-ReqSum(BASE_ECOLE[year==2020,],c("Lig_Indus","Col_Indus"),OptMRIO=T,OptStruct=TRUE) # Pareil en structure. --> On garde donc la même dimension que le fichier initial mais les montants sont en % du total par pays.
Test_A17_ReqSum<-ReqSum(BASE_A17[year==2020,],c("Lig_Indus","Col_Indus"),OptMRIO=T,OptStruct=TRUE) # Pareil en structure. --> On garde donc la même dimension que le fichier initial mais les montants sont en % du total par pays.

# Ajout et suppression de codes agrégés (BR en colonne et PR en ligne) pour faciliter la lecture en tableau
 Test_ECOLE_1995 <-AjoutPRBR(BASE_ECOLE[year==1995,])
 Test_ECOLE_1995_tab<-dcast(Test_ECOLE_1995,MRIO + PR ~ BR ,value.var="value") # C'est plus lisible comme ça ! Regarder la définition des variables dans le disctionnaire des variables.
Test_ECOLE_1995_detab<-melt(Test_ECOLE_1995_tab) # On repasse dans un format de base de données
setnames(Test_ECOLE_1995_detab,"variable","BR")  # On renomme la colonne 'variable' générée automatiquement par le melt en "BR"
Test_ECOLE_1995_Split<-SplitPRBR(Test_ECOLE_1995_detab) # On est revenus au format initial (on a perdu quelques variables au passage, donc a voir selon l'usage)

```


Manipulation des bases de départ détaillées (chacune sur une période différente, avec des pays différents et produits différents)
```{r}
# Quelques manipulations équivalentes à celles du chunck précédent mais sur les bases détaillées
# Attention a bien vérifier que l'année est bien dans le scope de la base, et que l'option OptMRIO est bien a FALSE lorsque nécessaire.
Test_WIOD_select<-BASE_WIOD[year==2004 & Lig_Country==Col_Country,] # Sélection des parties domestiques pour l'année 2020 sur WIOD
Test_LRWIOD_select<-BASE_LRWIOD[year==1978 & Lig_Country=="FRA",] # Ici sélection de l'équilibre ressources emploi de la FRA : production et CI et DF (décomposées par pays et branche de destination)
Test_FIG_select<-BASE_FIG[year==2020 & Lig_Country==Col_Country & Lig_Country=="FRA",] # Parties domestiques de Figaro   --> on remarque qu'on sélectionne a la fois les CI et la demande finale.
Test_FIG_select<-BASE_FIG[year==2020 & Lig_Country!=Col_Country & Lig_Country=="FRA",] # Parties non-domestiques de Figaro pour les blocs en ligne correspondant à la FRA
Test_FIG_ReqSum<-ReqSum(BASE_FIG,c("Lig_Country","Col_Country"),OptMRIO=F) # On agrège sur toute la période de Figaro les pays en une seule zone géographique et on conserve la distinction par branches et notamment la demande finale.
print(unique(BASE_WIOD[,Col_Indus])) # Liste des branches de WIOD en colonne

```


Exploitation des résultats relatifs aux MADE-IN
```{r}
# Exploitation des bases : BASEres_MADEINs_ECOLE ; BASEres_MADEINs_A17 ; BASEres_MADEINs_LRWIO ; BASEres_MADEINs_WIOD ; BASEres_MADEINs_FIGARO

# Le made-in France avec MRIO_ECOLE
MadeInFrance_ECOLE<-BASEres_MADEINs_ECOLE[Col_Country=="FRA",]
MadeInFrance_ECOLE_tab<-dcast(MadeInFrance_ECOLE,Lig_Indus ~ year ,value.var="value") 
MadeInFrance_ECOLE_ttab<-AddRownamesToFirstCol(t(MadeInFrance_ECOLE_tab))
colnames(MadeInFrance_ECOLE_ttab)<-MadeInFrance_ECOLE_ttab[1,]
MadeInFrance_ECOLE_ttab<-MadeInFrance_ECOLE_ttab[-1,]
MadeInFrance_ECOLE_ttab<-setDF(MadeInFrance_ECOLE_ttab)
MadeInFrance_ECOLE_ttab<- mutate_all(MadeInFrance_ECOLE_ttab, function(x) as.numeric(as.character(x)))

plot(MadeInFrance_ECOLE_ttab$TOTAL ~  MadeInFrance_ECOLE_ttab$Lig_Indus,type="l")

matplot(MadeInFrance_ECOLE_ttab$Lig_Indus, MadeInFrance_ECOLE_ttab[,2:6],type="b",col= hcl.colors(10, "Temps"),pch=c(16,1),xlab="années",ylab="Made-Ins par branche",main="Made-In France à partie de MRIO_ECOLE")
legend(x="bottomleft", legend=c("agrindu","nrj","servAbrit","servexpo","total"), fill =hcl.colors(10, "Temps"))


# Le made-in France avec MRIO_A17
MadeInFrance_A17<-BASEres_MADEINs_A17[Col_Country=="FRA",]
MadeInFrance_A17_tab<-dcast(MadeInFrance_A17,Lig_Indus ~ year ,value.var="value") 
MadeInFrance_A17_ttab<-AddRownamesToFirstCol(t(MadeInFrance_A17_tab))
colnames(MadeInFrance_A17_ttab)<-MadeInFrance_A17_ttab[1,]
MadeInFrance_A17_ttab<-MadeInFrance_A17_ttab[-1,]
MadeInFrance_A17_ttab<-setDF(MadeInFrance_A17_ttab)
MadeInFrance_A17_ttab<- mutate_all(MadeInFrance_A17_ttab, function(x) as.numeric(as.character(x)))

plot(MadeInFrance_A17_ttab$TOTAL ~  MadeInFrance_A17_ttab$Lig_Indus,type="l")

List_BR<-colnames(MadeInFrance_A17_ttab)[2:19]
matplot(MadeInFrance_A17_ttab$Lig_Indus, MadeInFrance_A17_ttab[,2:19],type="b",col= hcl.colors(10, "Temps"),pch=c(16,1),xlab="années",ylab="Made-Ins par branche",main="Made-In France à partie de MRIO_A17")
legend(x="bottomleft", text.font=1,legend=List_BR, fill =hcl.colors(10, "Temps"))

```


Exploitation des résultats relatifs aux contenus en VA des exports
```{r}
# Exploitation des bases : BASEres_ContVAdesExports_ECOLE ; BASEres_ContVAdesExports_A17 ; BASEres_ContVAdesExports_LRWIO ; BASEres_ContVAdesExports_WIOD

# Les contenus en VA des exports de la FRA avec MRIO_ECOLE
ContVAdesExports_ECOLE<-BASEres_ContVAdesExports_ECOLE[Col_Country=="FRA",]
print(unique(ContVAdesExports_ECOLE$Compo)) # Pour voir les éléments de cette variable
ContVAdesExports_ECOLE<-ContVAdesExports_ECOLE[Compo=="VAXnoguera_PR",] # Selection d'une composante

ContVAdesExports_ECOLE_tab<-dcast(ContVAdesExports_ECOLE,Lig_Indus ~ yearREF ,value.var="value") 
ContVAdesExports_ECOLE_ttab<-AddRownamesToFirstCol(t(ContVAdesExports_ECOLE_tab))
colnames(ContVAdesExports_ECOLE_ttab)<-ContVAdesExports_ECOLE_ttab[1,]
ContVAdesExports_ECOLE_ttab<-ContVAdesExports_ECOLE_ttab[-1,]
ContVAdesExports_ECOLE_ttab<-setDF(ContVAdesExports_ECOLE_ttab)
ContVAdesExports_ECOLE_ttab<- mutate_all(ContVAdesExports_ECOLE_ttab, function(x) as.numeric(as.character(x)))

matplot(ContVAdesExports_ECOLE_ttab$Lig_Indus, ContVAdesExports_ECOLE_ttab[,2:5],type="b",col= hcl.colors(10, "Temps"),pch=c(16,1),xlab="années",ylab="VAX Noguera",main="Contenu en VA des Exports au sens de Noguera")
legend(x="bottomleft", legend=c("agrindu","nrj","servAbrit","servexpo"), fill =hcl.colors(10, "Temps"))


# Les contenus en VA des exports de la FRA avec MRIO_ECOLE : tous indicateurs
ContVAdesExports_ECOLE<-BASEres_ContVAdesExports_ECOLE[Col_Country=="TOTAL" & Lig_Country=="TOTAL" & Lig_Indus=="TOTAL",]
ContVAdesExports_ECOLE_tab<-dcast(unique(ContVAdesExports_ECOLE),Compo + CountryREF ~ yearREF ,value.var="value") 

# On souhait emaintenant ne conserver que l'indicateur VAXnoguera_tot et le rapporter à la valeur ajoutée.
ContVAdesExports_ECOLE<-ContVAdesExports_ECOLE[Compo=="VAXnoguera_tot",]
VAcorrespondante<-BASEres_ContVAdesExports_ECOLE[Compo=="VA" ,] # Attention a ce stade on voit qu'on a une information par Col_Country et Col_Indus, qu'il va donc falloir agréger)
VAcorrespondante<-VAcorrespondante[, sum(value),by=c("Compo","CountryREF","yearREF")]
setnames(VAcorrespondante,"V1","value")
VAcorrespondante<-VAcorrespondante[,Col_Country:="TOTAL"][,Col_Indus:="TOTAL"][,Lig_Country:="TOTAL"][,Lig_Indus:="TOTAL"]
ContVAdesExports_ECOLE<-rbind(ContVAdesExports_ECOLE,VAcorrespondante)
ContVAdesExports_ECOLE<-unique(ContVAdesExports_ECOLE)
ContVAdesExports_ECOLE <- ContVAdesExports_ECOLE[, value:=as.numeric(value)]
ContVAdesExports_ECOLE_tab<-dcast(unique(ContVAdesExports_ECOLE),Compo + CountryREF ~ yearREF ,value.var="value") 
ratio<-ContVAdesExports_ECOLE_tab[6:10,] # Initialise
ratio[1:5,3:ncol(ratio)]<-ContVAdesExports_ECOLE_tab[6:10,3:ncol(ratio)]/ContVAdesExports_ECOLE_tab[1:5,3:ncol(ratio)]
tratio<-t(ratio)
tratio<-as.data.frame(tratio[-1,])
colnames(tratio)<-tratio[1,]
tratio<-as.data.frame(tratio[-1,])

matplot(rownames(tratio), tratio,type="b",col= hcl.colors(10, "Temps"),pch=c(16,1),xlab="années",ylab="Contenu en VAX (Noguera) dans la VA",main="Contenu en VAX (Noguera) dans la VA")
legend(x="bottomleft", text.font=1,legend=c("Chine","France","Reste du monde","UEautres","USA"), fill =hcl.colors(10, "Temps"))

```


Exploitation des résultats relatifs à la décomposition offshoring/reshoring/reoffshoring (GAO)
```{r}
### Utilisation de la base de résultats :    / BASEres_GAO_ECOLE ; BASEres_GAO_A17 ; BASEres_GAO_LRWIO
Split_GAO_ECOLE<-SplitPRBR(BASEres_GAO_ECOLE) # Pour décomposer les pays et branches
GAO_ECOLE_selectFRA<-Split_GAO_ECOLE[Lig_Country=="FRA" & Col_Country=="FRA",]
GAO_ECOLE_selectFRA<-AjoutPRBR(GAO_ECOLE_selectFRA)
GAO_ECOLE_selectFRA_tab<-dcast(GAO_ECOLE_selectFRA,gao_res + PR ~ BR + year  ,value.var="value") 

### Utilisation de la fonction
GAO_ECOLE<-GAO(BASE_ECOLE,1978,1979,OptMRIO=TRUE)
print(GAO_ECOLE[["r1"]])  # composante r1 de la décomposition GAO
print(GAO_ECOLE[["r2"]])  # composante r2 de la décomposition GAO
print(GAO_ECOLE[["r3"]])  # composante r3 de la décomposition GAO

GAO_A17<-GAO(BASE_A17,2007,2008,OptMRIO=TRUE)

GAO_LRWIOD<-GAO(BASE_LRWIOD,1993,1994,OptMRIO=FALSE)
GAO_WIOD<-GAO(BASE_WIOD,2007,2008,OptMRIO=FALSE)
GAO_FIG<-GAO(BASE_FIG,2012,2013,OptMRIO=FALSE)
```


Manipulation des la fonction HEM pour les calculs de linkage
```{r}
HEM_1990_A17<-HEM(BASE_A17,1990,extract_country="FRA",extract_indus="AZ",verboseCheck=TRUE,OptMRIO=TRUE,OptAmontAval="ALL") # Attention a bien vérifier que les codes correspondent bien à la nomenclature du MRIO considéré.
print(HEM_1990_A17[["Indic_HEM"]])  # Valeur de l'indicateur HEM

HEM_1990_A17_amont<-HEM(BASE_A17,1990,extract_country="FRA",extract_indus="AZ",verboseCheck=F,OptMRIO=TRUE,OptAmontAval="Amont") # Attention a bien vérifier que les codes correspondent bien à la nomenclature du MRIO considéré.
print(HEM_1990_A17[["Indic_HEM"]])  # Valeur de l'indicateur HEM amont

HEM_1990_A17_aval<-HEM(BASE_A17,1990,extract_country="FRA",extract_indus="AZ",verboseCheck=F,OptMRIO=TRUE,OptAmontAval="Aval") # Attention a bien vérifier que les codes correspondent bien à la nomenclature du MRIO considéré.
print(HEM_1990_A17[["Indic_HEM"]])  # Valeur de l'indicateur HEM aval

HEM_1<-HEM(BASE_A17,1990,extract_country="FRA",extract_indus="AZ",verboseCheck=F) 
HEM_2<-HEM(BASE_A17,1990,extract_country="FRA",extract_indus="DE",verboseCheck=F) 
HEM_3<-HEM(BASE_A17,1990,extract_country="CHN",extract_indus="DE",verboseCheck=F) 
print(c(HEM_1[["Indic_HEM"]],HEM_2[["Indic_HEM"]],HEM_3[["Indic_HEM"]]))

HEM_2007_WIOD<-HEM(BASE_WIOD,2007,extract_country="FRA",extract_indus="A01",verboseCheck=TRUE,OptMRIO=FALSE) # Sur base complète WIOD.

```


Manipulation des la fonction LinkageBwdFwd pour les calculs de linkage Backward et Forward
```{r}
# Exploitation des bases : BASEres_LinkageBwdFwd_ECOLE ; BASEres_LinkageBwdFwd_A17 ; BASEres_LinkageBwdFwd_LRWIO 

#### Backward linkage sur base A17
LinkageBwdFwd_A17_Bwd<-BASEres_LinkageBwdFwd_A17[["Indic_Bwd_byCountry"]][Lig_Country=="FRA",]
  
LinkageBwdFwd_A17_Bwd_tab<-dcast(LinkageBwdFwd_A17_Bwd,Lig_Indus ~ year ,value.var="value") 
LinkageBwdFwd_A17_Bwd_ttab<-AddRownamesToFirstCol(t(LinkageBwdFwd_A17_Bwd_tab))
colnames(LinkageBwdFwd_A17_Bwd_ttab)<-LinkageBwdFwd_A17_Bwd_ttab[1,]
LinkageBwdFwd_A17_Bwd_ttab<-LinkageBwdFwd_A17_Bwd_ttab[-1,]
LinkageBwdFwd_A17_Bwd_ttab<-setDF(LinkageBwdFwd_A17_Bwd_ttab)
LinkageBwdFwd_A17_Bwd_ttab<- mutate_all(LinkageBwdFwd_A17_Bwd_ttab, function(x) as.numeric(as.character(x)))

List_BR<-colnames(LinkageBwdFwd_A17_Bwd_ttab)[2:18]
matplot(LinkageBwdFwd_A17_Bwd_ttab$Lig_Indus, LinkageBwdFwd_A17_Bwd_ttab[,2:18],type="b",col= hcl.colors(10, "Temps"),pch=c(16,1),xlab="années",ylab="Indic linkage",main="Backward Linkage de la France au format A17")
legend(x="bottomleft", legend=List_BR, fill =hcl.colors(10, "Temps"))


#### Forward linkage sur base A17
LinkageBwdFwd_A17_Fwd<-BASEres_LinkageBwdFwd_A17[["Indic_Fwd_byCountry"]][Col_Country=="FRA",]
  
LinkageBwdFwd_A17_Fwd_tab<-dcast(LinkageBwdFwd_A17_Fwd,Col_Indus ~ year ,value.var="value") 
LinkageBwdFwd_A17_Fwd_ttab<-AddRownamesToFirstCol(t(LinkageBwdFwd_A17_Fwd_tab))
colnames(LinkageBwdFwd_A17_Fwd_ttab)<-LinkageBwdFwd_A17_Fwd_ttab[1,]
LinkageBwdFwd_A17_Fwd_ttab<-LinkageBwdFwd_A17_Fwd_ttab[-1,]
LinkageBwdFwd_A17_Fwd_ttab<-setDF(LinkageBwdFwd_A17_Fwd_ttab)
LinkageBwdFwd_A17_Fwd_ttab<- mutate_all(LinkageBwdFwd_A17_Fwd_ttab, function(x) as.numeric(as.character(x)))

List_BR<-colnames(LinkageBwdFwd_A17_Fwd_ttab)[2:18]
matplot(LinkageBwdFwd_A17_Fwd_ttab$Col_Indus, LinkageBwdFwd_A17_Fwd_ttab[,2:18],type="b",col= hcl.colors(10, "Temps"),pch=c(16,1),xlab="années",ylab="Indic linkage",main="Forward Linkage de la France au format A17")
legend(x="bottomleft", legend=List_BR, fill =hcl.colors(10, "Temps"))


#### Backward linkage sur base ECOLE et sur toute la période
LinkageBwdFwd_ECOLE_Bwd<-BASEres_LinkageBwdFwd_ECOLE[["Indic_Bwd_byCountry"]][Lig_Country=="FRA",]
  
LinkageBwdFwd_ECOLE_Bwd_tab<-dcast(LinkageBwdFwd_ECOLE_Bwd,Lig_Indus ~ year ,value.var="value") 
LinkageBwdFwd_ECOLE_Bwd_ttab<-AddRownamesToFirstCol(t(LinkageBwdFwd_ECOLE_Bwd_tab))
colnames(LinkageBwdFwd_ECOLE_Bwd_ttab)<-LinkageBwdFwd_ECOLE_Bwd_ttab[1,]
LinkageBwdFwd_ECOLE_Bwd_ttab<-LinkageBwdFwd_ECOLE_Bwd_ttab[-1,]
LinkageBwdFwd_ECOLE_Bwd_ttab<-setDF(LinkageBwdFwd_ECOLE_Bwd_ttab)
LinkageBwdFwd_ECOLE_Bwd_ttab<- mutate_all(LinkageBwdFwd_ECOLE_Bwd_ttab, function(x) as.numeric(as.character(x)))

List_BR<-colnames(LinkageBwdFwd_ECOLE_Bwd_ttab)[2:5]
matplot(LinkageBwdFwd_ECOLE_Bwd_ttab$Lig_Indus, LinkageBwdFwd_ECOLE_Bwd_ttab[,2:5],type="b",col= hcl.colors(10, "Temps"),pch=c(16,1),xlab="années",ylab="Indic linkage",main="Backward Linkage de la France au format ECOLE")
legend(x="bottomleft", legend=List_BR, fill =hcl.colors(10, "Temps"))
```



Manipulation de la fonction HRM (hypothetical repatriation method) pour effectuer des simulations de rappatriement
```{r}
BASE_A17_1990<-BASE_A17[year==1990,]
HRM_1990_A17<-HRM(BASE_A17_1990,repat_country="FRA",repat_indus="AZ",repat_pct=0.3,verboseCheck=TRUE)  

HRM_1990_diff<-HRM_1990_A17[["Diff"]]
HRM_1990_diff<-as.data.frame(HRM_1990_diff)
HRM_1990_select<-HRM_1990_diff[!(HRM_1990_diff == 0), ]
print(HRM_1990_select) # On sélectionne les lignes non-nulles, sur lesquelles des ajustements on été passées (identifiables dans le tabeau Diff de l'objet résultat.)
print(colSums(HRM_1990_diff)) # On vérifie que la somme en colonne est bien nulle
print(max(colSums(HRM_1990_diff))) # On vérifie que la somme en colonne est bien nulle

BASE_ECOLE_1990<-BASE_ECOLE[year==1990,]
HRM_1990_ECOLE<-HRM(BASE_ECOLE_1990,repat_country="FRA",repat_indus="AGR_INDU",repat_pct=0.3,verboseCheck=TRUE)  

#VRAI_WIOD_FULL_2007_FULL<-CompoMRIO(Interm_WIOD,"OptFullOptions",date=2007)
WIOD_2007<-BASE_WIOD[year==2007,]
HRM_2007_WIOD<-HRM(WIOD_2007,repat_country="FRA",repat_indus="A01",repat_pct=0.3,verboseCheck=TRUE,OptMRIO=FALSE)  
```








